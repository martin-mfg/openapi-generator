{-
   dummy

   dummy

   OpenAPI Version: 3.0.0
   dummy API version: dummy
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : Dummy.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Dummy.Model where

import Dummy.Core
import Dummy.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- * Models


-- ** Dummy200Response
-- | Dummy200Response
data Dummy200Response = Dummy200Response
  { dummy200ResponseOuterProp :: !(Maybe Dummy200ResponseOuterProp) -- ^ "outerProp"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Dummy200Response
instance A.FromJSON Dummy200Response where
  parseJSON = A.withObject "Dummy200Response" $ \o ->
    Dummy200Response
      <$> (o .:? "outerProp")

-- | ToJSON Dummy200Response
instance A.ToJSON Dummy200Response where
  toJSON Dummy200Response {..} =
   _omitNulls
      [ "outerProp" .= dummy200ResponseOuterProp
      ]


-- | Construct a value of type 'Dummy200Response' (by applying it's required fields, if any)
mkDummy200Response
  :: Dummy200Response
mkDummy200Response =
  Dummy200Response
  { dummy200ResponseOuterProp = Nothing
  }

-- ** Dummy200ResponseOuterProp
-- | Dummy200ResponseOuterProp
data Dummy200ResponseOuterProp = Dummy200ResponseOuterProp
  { dummy200ResponseOuterPropInnerProp :: !(Maybe Dummy200ResponseOuterPropInnerProp) -- ^ "innerProp"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Dummy200ResponseOuterProp
instance A.FromJSON Dummy200ResponseOuterProp where
  parseJSON = A.withObject "Dummy200ResponseOuterProp" $ \o ->
    Dummy200ResponseOuterProp
      <$> (o .:? "innerProp")

-- | ToJSON Dummy200ResponseOuterProp
instance A.ToJSON Dummy200ResponseOuterProp where
  toJSON Dummy200ResponseOuterProp {..} =
   _omitNulls
      [ "innerProp" .= dummy200ResponseOuterPropInnerProp
      ]


-- | Construct a value of type 'Dummy200ResponseOuterProp' (by applying it's required fields, if any)
mkDummy200ResponseOuterProp
  :: Dummy200ResponseOuterProp
mkDummy200ResponseOuterProp =
  Dummy200ResponseOuterProp
  { dummy200ResponseOuterPropInnerProp = Nothing
  }

-- ** Dummy200ResponseOuterPropInnerProp
-- | Dummy200ResponseOuterPropInnerProp
data Dummy200ResponseOuterPropInnerProp = Dummy200ResponseOuterPropInnerProp
  { dummy200ResponseOuterPropInnerPropMyBool :: !(Maybe Bool) -- ^ "myBool"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Dummy200ResponseOuterPropInnerProp
instance A.FromJSON Dummy200ResponseOuterPropInnerProp where
  parseJSON = A.withObject "Dummy200ResponseOuterPropInnerProp" $ \o ->
    Dummy200ResponseOuterPropInnerProp
      <$> (o .:? "myBool")

-- | ToJSON Dummy200ResponseOuterPropInnerProp
instance A.ToJSON Dummy200ResponseOuterPropInnerProp where
  toJSON Dummy200ResponseOuterPropInnerProp {..} =
   _omitNulls
      [ "myBool" .= dummy200ResponseOuterPropInnerPropMyBool
      ]


-- | Construct a value of type 'Dummy200ResponseOuterPropInnerProp' (by applying it's required fields, if any)
mkDummy200ResponseOuterPropInnerProp
  :: Dummy200ResponseOuterPropInnerProp
mkDummy200ResponseOuterPropInnerProp =
  Dummy200ResponseOuterPropInnerProp
  { dummy200ResponseOuterPropInnerPropMyBool = Nothing
  }

-- ** ExampleResponse
-- | ExampleResponse
-- dummy
data ExampleResponse = ExampleResponse
  { exampleResponseEmptyString :: !(Maybe Text) -- ^ "emptyString"
  , exampleResponseNumberString :: !(Maybe Text) -- ^ "numberString"
  , exampleResponseBoolString :: !(Maybe Text) -- ^ "boolString"
  , exampleResponseNullString :: !(Maybe Text) -- ^ "nullString"
  , exampleResponseABool :: !(Maybe Bool) -- ^ "aBool"
  , exampleResponseZero :: !(Maybe Int) -- ^ "zero"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExampleResponse
instance A.FromJSON ExampleResponse where
  parseJSON = A.withObject "ExampleResponse" $ \o ->
    ExampleResponse
      <$> (o .:? "emptyString")
      <*> (o .:? "numberString")
      <*> (o .:? "boolString")
      <*> (o .:? "nullString")
      <*> (o .:? "aBool")
      <*> (o .:? "zero")

-- | ToJSON ExampleResponse
instance A.ToJSON ExampleResponse where
  toJSON ExampleResponse {..} =
   _omitNulls
      [ "emptyString" .= exampleResponseEmptyString
      , "numberString" .= exampleResponseNumberString
      , "boolString" .= exampleResponseBoolString
      , "nullString" .= exampleResponseNullString
      , "aBool" .= exampleResponseABool
      , "zero" .= exampleResponseZero
      ]


-- | Construct a value of type 'ExampleResponse' (by applying it's required fields, if any)
mkExampleResponse
  :: ExampleResponse
mkExampleResponse =
  ExampleResponse
  { exampleResponseEmptyString = Nothing
  , exampleResponseNumberString = Nothing
  , exampleResponseBoolString = Nothing
  , exampleResponseNullString = Nothing
  , exampleResponseABool = Nothing
  , exampleResponseZero = Nothing
  }

-- ** Node
-- | Node
-- dummy
data Node = Node
  { nodeLeft :: !(Maybe Node) -- ^ "left"
  , nodeRight :: !(Maybe Node) -- ^ "right"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Node
instance A.FromJSON Node where
  parseJSON = A.withObject "Node" $ \o ->
    Node
      <$> (o .:? "left")
      <*> (o .:? "right")

-- | ToJSON Node
instance A.ToJSON Node where
  toJSON Node {..} =
   _omitNulls
      [ "left" .= nodeLeft
      , "right" .= nodeRight
      ]


-- | Construct a value of type 'Node' (by applying it's required fields, if any)
mkNode
  :: Node
mkNode =
  Node
  { nodeLeft = Nothing
  , nodeRight = Nothing
  }

-- ** OtherObject
-- | OtherObject
-- dummy
data OtherObject = OtherObject
  { otherObjectMyOnlyProperty2 :: !(Maybe ExampleResponse) -- ^ "myOnlyProperty2"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OtherObject
instance A.FromJSON OtherObject where
  parseJSON = A.withObject "OtherObject" $ \o ->
    OtherObject
      <$> (o .:? "myOnlyProperty2")

-- | ToJSON OtherObject
instance A.ToJSON OtherObject where
  toJSON OtherObject {..} =
   _omitNulls
      [ "myOnlyProperty2" .= otherObjectMyOnlyProperty2
      ]


-- | Construct a value of type 'OtherObject' (by applying it's required fields, if any)
mkOtherObject
  :: OtherObject
mkOtherObject =
  OtherObject
  { otherObjectMyOnlyProperty2 = Nothing
  }





